# =============================================================================
# TIKTOK CLONE - AWS EKS DEPLOYMENT WORKFLOW
# =============================================================================
# Deploy to AWS EKS using Terraform and Helm
# Optimized for ~$199/month budget with SPOT instances
# =============================================================================

name: Deploy to AWS EKS

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - plan-only
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - prod
          - staging
      skip_terraform:
        description: 'Skip Terraform (only update Helm)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: tiktok-clone-eks
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}
  TF_WORKING_DIR: terraform/aws-eks

jobs:
  # ===========================================================================
  # TERRAFORM PLAN
  # ===========================================================================
  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.action != 'destroy' }}

    outputs:
      plan_exit_code: ${{ steps.plan.outputs.exitcode }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Setup Backend Infrastructure
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "=========================================="
          echo "  Ensuring S3 Backend Exists"
          echo "=========================================="

          # Check if S3 bucket exists
          if ! aws s3 ls s3://tiktok-clone-terraform-state 2>/dev/null; then
            echo "Backend bucket does not exist. Creating..."

            # Temporarily init without backend to create it
            cat > backend_override.tf << 'EOF'
          terraform {
            backend "local" {}
          }
          EOF

            terraform init -reconfigure

            # Create backend resources
            terraform apply -target=aws_s3_bucket.terraform_state \
                           -target=aws_s3_bucket_versioning.terraform_state \
                           -target=aws_s3_bucket_server_side_encryption_configuration.terraform_state \
                           -target=aws_s3_bucket_public_access_block.terraform_state \
                           -target=aws_dynamodb_table.terraform_locks \
                           -auto-approve

            echo "‚úì Backend infrastructure created"

            # Remove override and migrate to S3
            rm -f backend_override.tf
            terraform init -migrate-state -force-copy

            echo "‚úì State migrated to S3"
          else
            echo "‚úì Backend bucket already exists"
          fi

      - name: Terraform Init (Plan Phase)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -reconfigure

          # Verify state backend
          echo ""
          echo "State backend configuration:"
          terraform version
          echo ""
          echo "‚úì Using remote state in S3"

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_redis_password: ${{ secrets.REDIS_PASSWORD }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_environment: ${{ github.event.inputs.environment }}
        run: |
          terraform plan -detailed-exitcode -out=tfplan 2>&1 | tee plan.txt
          echo "exitcode=$?" >> $GITHUB_OUTPUT

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            ${{ env.TF_WORKING_DIR }}/tfplan
            ${{ env.TF_WORKING_DIR }}/plan.txt

  # ===========================================================================
  # TERRAFORM APPLY
  # ===========================================================================
  terraform-apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    needs: [terraform-plan, build-images]
    # Run after BOTH plan and build complete successfully
    if: |
      always() &&
      github.event.inputs.action == 'deploy'
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init (Apply Phase)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -reconfigure

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_redis_password: ${{ secrets.REDIS_PASSWORD }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_environment: ${{ github.event.inputs.environment }}
        run: terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: outputs
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "cluster_endpoint=$(terraform output -raw cluster_endpoint)" >> $GITHUB_OUTPUT

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

  # ===========================================================================
  # BUILD & PUSH IMAGES
  # ===========================================================================
  build-images:
    name: 'Build & Push Images'
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.action == 'deploy' }}

    strategy:
      matrix:
        service:
          - api-gateway
          - auth-service
          - video-service
          - interaction-service
          - notification-service

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.service }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================================================================
  # DEPLOY TO EKS
  # ===========================================================================
  deploy-eks:
    name: 'Deploy to EKS'
    runs-on: ubuntu-latest
    needs: [terraform-apply, build-images, terraform-apply]
    # Deploy after both Apply and Build complete successfully
    if: |
      always() &&
      github.event.inputs.action == 'deploy' &&
      needs.build-images.result == 'success' &&
      (needs.terraform-apply.result == 'success' || github.event.inputs.skip_terraform)
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

          # Verify cluster access
          echo "Verifying cluster access..."
          kubectl cluster-info
          kubectl get nodes

          # Wait for cluster to be ready
          echo "Waiting for cluster to be fully ready..."
          kubectl wait --for=condition=Ready nodes --all --timeout=300s || true

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      - name: Deploy with Helm
        run: |
          # Create namespace if not exists
          kubectl create namespace tiktok-clone-${{ github.event.inputs.environment }} --dry-run=client -o yaml | kubectl apply -f - --validate=false

          # Create GHCR secret
          kubectl create secret docker-registry ghcr-secret \
            --namespace tiktok-clone-${{ github.event.inputs.environment }} \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f - --validate=false

          # Deploy using Helm
          helm upgrade --install tiktok-clone ./helm/tiktok-clone \
            --namespace tiktok-clone-${{ github.event.inputs.environment }} \
            -f ./helm/tiktok-clone/values.yaml \
            -f ./helm/tiktok-clone/values-aws.yaml \
            --set global.environment=${{ github.event.inputs.environment }} \
            --set services.gateway.image.tag=${{ github.sha }} \
            --set services.auth.image.tag=${{ github.sha }} \
            --set services.video.image.tag=${{ github.sha }} \
            --set services.interaction.image.tag=${{ github.sha }} \
            --set services.notification.image.tag=${{ github.sha }} \
            --wait --timeout 10m

      - name: Verify Deployment
        run: |
          echo "=== Pods ==="
          kubectl get pods -n tiktok-clone-${{ github.event.inputs.environment }}

          echo "=== Services ==="
          kubectl get svc -n tiktok-clone-${{ github.event.inputs.environment }}

          echo "=== Ingress (ALB) ==="
          kubectl get ingress -n tiktok-clone-${{ github.event.inputs.environment }}

          echo "=== HPA ==="
          kubectl get hpa -n tiktok-clone-${{ github.event.inputs.environment }}

      - name: Get Application URL
        id: url
        run: |
          # Wait for ALB to be ready
          sleep 30
          ALB_URL=$(kubectl get ingress tiktok-clone-ingress -n tiktok-clone-${{ github.event.inputs.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          echo "url=$ALB_URL" >> $GITHUB_OUTPUT
          echo "üöÄ Application URL: http://$ALB_URL"

  # ===========================================================================
  # TERRAFORM DESTROY
  # ===========================================================================
  terraform-destroy:
    name: 'Terraform Destroy - Complete Cleanup'
    runs-on: ubuntu-latest
    # Can run anytime when 'destroy' action is selected
    if: github.event.inputs.action == 'destroy'
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        continue-on-error: true
        run: |
          echo "Connecting to cluster..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }} || echo "Cluster may not exist"

      - name: Clean up Kubernetes resources
        continue-on-error: true
        run: |
          echo "=========================================="
          echo "  Cleaning up Kubernetes resources..."
          echo "=========================================="

          # Delete Helm releases first (this removes LoadBalancers)
          if kubectl get namespace tiktok-clone-${{ github.event.inputs.environment }} 2>/dev/null; then
            echo "Uninstalling Helm release..."
            helm uninstall tiktok-clone -n tiktok-clone-${{ github.event.inputs.environment }} --wait --timeout 5m || true

            # Delete namespace (this removes any remaining resources)
            echo "Deleting namespace..."
            kubectl delete namespace tiktok-clone-${{ github.event.inputs.environment }} --wait=true --timeout=10m || true
          fi

          # Wait for LoadBalancers to be fully deleted
          echo "Waiting for LoadBalancers to be cleaned up..."
          sleep 60

          echo "‚úì Kubernetes cleanup complete"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init (Destroy Phase)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -reconfigure

      - name: Terraform Destroy
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_redis_password: ${{ secrets.REDIS_PASSWORD }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_environment: ${{ github.event.inputs.environment }}
        run: |
          echo "=========================================="
          echo "  Destroying EKS infrastructure..."
          echo "=========================================="

          terraform destroy -auto-approve

          if [ $? -eq 0 ]; then
            echo ""
            echo "‚úì Infrastructure destroyed successfully!"
            echo ""
            echo "‚ö† IMPORTANT: Check for remaining resources:"
            echo "  - Elastic IPs"
            echo "  - NAT Gateways (may take 5-10 min to delete)"
            echo "  - LoadBalancers (should be deleted)"
            echo "  - VPC (will be deleted last)"
          else
            echo ""
            echo "‚úó Destroy failed. Check errors above."
            echo "You may need to manually clean up resources."
            exit 1
          fi

      - name: Verify cleanup
        continue-on-error: true
        run: |
          echo "=========================================="
          echo "  Verifying cleanup..."
          echo "=========================================="

          # Check for remaining EKS clusters
          echo "Checking for EKS clusters..."
          aws eks list-clusters --region ${{ env.AWS_REGION }} --query 'clusters' --output text

          # Check for remaining VPCs (except default)
          echo ""
          echo "Checking for VPCs..."
          aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --filters "Name=tag:Project,Values=tiktok-clone" --query 'Vpcs[*].[VpcId,Tags[?Key==`Name`].Value|[0]]' --output table || true

          # Check for LoadBalancers
          echo ""
          echo "Checking for LoadBalancers..."
          aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[?contains(LoadBalancerName, `tiktok`) || contains(LoadBalancerName, `k8s`)].LoadBalancerName' --output table || true

          echo ""
          echo "‚úì Verification complete"

      - name: Cleanup summary
        if: always()
        run: |
          echo ""
          echo "=========================================="
          echo "  üóëÔ∏è  CLEANUP SUMMARY"
          echo "=========================================="
          echo ""
          echo "Destroyed resources:"
          echo "  ‚úì Helm releases"
          echo "  ‚úì Kubernetes namespaces"
          echo "  ‚úì EKS cluster"
          echo "  ‚úì Node groups"
          echo "  ‚úì VPC and networking"
          echo "  ‚úì Security groups"
          echo "  ‚úì IAM roles"
          echo ""
          echo "‚ö†  Manual cleanup may be needed for:"
          echo "  ‚Ä¢ NAT Gateway deletion (takes 5-10 minutes)"
          echo "  ‚Ä¢ Elastic IPs (check EC2 console)"
          echo "  ‚Ä¢ S3 buckets (not managed by Terraform)"
          echo ""
          echo "=========================================="

  # ===========================================================================
  # COST NOTIFICATION
  # ===========================================================================
  notify-cost:
    name: 'Cost Estimation'
    runs-on: ubuntu-latest
    needs: deploy-eks
    if: ${{ always() && github.event.inputs.action == 'deploy' }}

    steps:
      - name: Cost Breakdown
        run: |
          echo "=========================================="
          echo "  ESTIMATED MONTHLY COST (USD)"
          echo "=========================================="
          echo ""
          echo "  EKS Cluster:           ~\$72/month"
          echo "  2x t3.medium SPOT:     ~\$18/month"
          echo "  NAT Gateway (1 AZ):    ~\$32/month"
          echo "  EBS Storage (35GB):    ~\$3.50/month"
          echo "  Data Transfer:         ~\$5-10/month"
          echo "  ------------------------------------------"
          echo "  TOTAL ESTIMATE:        ~\$130-140/month"
          echo ""
          echo "  üí∞ Budget: \$199"
          echo "  ‚úÖ Buffer: ~\$60 for traffic spikes"
          echo "=========================================="
